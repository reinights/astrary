import { Canvas, useThree } from "@react-three/fiber";
import { OrbitControls, Cloud, CameraControls } from "@react-three/drei";
import * as THREE from "three";
import { useMemo, useRef, useEffect } from "react";
// @ts-ignore
import { julian } from "astronomia";

//ChatGPT Help with shaders and converting values from ra/dec/mag to xyza.
//Conversation Link:
//https://chatgpt.com/share/67ffd32e-c694-8009-b8fb-27b7b4ebda98
const vertexShader = `
  attribute float alpha;
  varying float vAlpha;

  void main() {
    vAlpha = alpha;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = 2.0;
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const fragmentShader = `
  varying float vAlpha;

  void main() {
    gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha);
  }
`;

export default function NightSky({
  stars,
  time,
  lat,
  lng,
  onStarClick,
  focusedStarId,
  setFocusedStarId,
}: {
  stars: any[];
  time: Date;
  lat: number;
  lng: number;
  onStarClick: (id: string) => void;
  focusedStarId: string | null;
  setFocusedStarId: (id: string | null) => void;
}) {
  console.log("Hello.");
  console.log(stars);
  //Function generated by ChatGPT: https://chatgpt.com/share/68013d8c-cb9c-8009-81e3-83b7db7676be
  function getGreenwichSiderealTimeRadians(jd: number): number {
    const T = (jd - 2451545.0) / 36525.0;

    let GMST =
      280.46061837 +
      360.98564736629 * (jd - 2451545.0) +
      0.000387933 * T * T -
      (T * T * T) / 38710000;

    GMST = ((GMST % 360) + 360) % 360; // normalize to 0–360°
    return (GMST * Math.PI) / 180; // convert to radians
  }

  //the astronomia function seems to only take in values from years, months, and days.
  //this function splits the d/m/y from the h/m/s, uses the former to get the julian from astronomia, and add the remaining time to it.
  function getJulianDateFromDate(date: Date): number {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1; // JS months are 0-based
    const day = date.getUTCDate();

    const hours = date.getUTCHours();
    const minutes = date.getUTCMinutes();
    const seconds = date.getUTCSeconds();

    //this returns the julian date as a day.
    const jd0 = julian.CalendarGregorianToJD(year, month, day);
    //as we want real time, we also need the time of the day, which is used as a decimal here.
    const timeFraction = (hours + minutes / 60 + seconds / 3600) / 24;

    return jd0 + timeFraction;
  }

  // stars.csv includes the Right Ascension / Declination (RA/Dec). This is useful for plotting, but not really for realtime. (kind of like a lat and lon.)
  // Azimuth / Altitude (Alt/Az) are location and time-based angles that tell you where to look in the sky right now, great for rendering the night sky from the user's location and time.
  // In order to convert RA/Dec to Alt/Az, we would also need the Local Sidereal Time, which is the time it takes for the Earth's rotation to hit 360 based on distant stars. RA is also measured in LST.
  // This is because stars appear to move through the sky throughout the night due to Earth's rotation, and LST helps us figure out what part of the celestial sphere is currently visible for the observer.
  // Without this, RA/Dec would remain stationary and it would be difficult to have have a realtime slider that can display stars based on the user's location and time.
  // Formulas used in here are generated by ChatGPT in this conversation //https://chatgpt.com/share/67ffd32e-c694-8009-b8fb-27b7b4ebda98, I have merely modified it to work.

  function convertStarsToGeometryData(
    stars: any[],
    radius: number,
    time: Date,
    lat: number,
    lng: number
  ) {
    time.setUTCSeconds(0, 0);

    const jd = getJulianDateFromDate(time);
    const gst = getGreenwichSiderealTimeRadians(jd);
    const lst = gst + (lng * Math.PI) / 180; //in radians, as the formula GPT gave me is based on radians.

    const total = stars.length;
    const positions = new Float32Array(total * 3);
    const alphas = new Float32Array(total);
    const starMap: Record<string, [number, number, number]> = {};

    let j = 0;
    let k = 0;

    for (let i = 0; i < total; i++) {
      const star = stars[i];
      if (star.ra == null || star.dec == null || star.mag == null) continue;

      const raRad = (star.ra * 15 * Math.PI) / 180;
      const decRad = (star.dec * Math.PI) / 180;
      const ha = lst - raRad;

      const latRad = (lat * Math.PI) / 180;
      const sinAlt =
        Math.sin(decRad) * Math.sin(latRad) +
        Math.cos(decRad) * Math.cos(latRad) * Math.cos(ha);
      const alt = Math.asin(sinAlt);

      const cosAz =
        (Math.sin(decRad) - Math.sin(alt) * Math.sin(latRad)) /
        (Math.cos(alt) * Math.cos(latRad));
      let az = Math.acos(Math.min(Math.max(cosAz, -1), 1));
      if (Math.sin(ha) > 0) az = 2 * Math.PI - az;

      const x = radius * Math.cos(alt) * Math.sin(-az);
      const y = radius * Math.sin(alt);
      const z = radius * Math.cos(alt) * Math.cos(-az);

      positions[j++] = x;
      positions[j++] = y;
      positions[j++] = z;

      const alpha = Math.max(0, 1 - star.mag / 4);
      alphas[k++] = alpha;

      //within there stars.csv file, there are certain columns that dictates the star's identity. Some of them are empty (unnamed ones) which uses these different values for fallback.
      //currently not used, but this essentially adds a name (key) to a stars position. I intend to use this in order to implement the button interactivity later on.
      const key = star.hip ? `HIP ${star.hip}` : null;

      if (key) {
        starMap[key] = [x, y, z];
      }
    }

    return {
      positions: positions.subarray(0, j),
      alphas: alphas.subarray(0, k),
      starMap,
    };
  }

  const { positions, alphas, starMap } = useMemo(() => {
    if (!stars?.length)
      return {
        positions: new Float32Array(),
        alphas: new Float32Array(),
        starMap: {},
      };
    return convertStarsToGeometryData(stars, 100, time, lat, lng);
  }, [stars, time, lat, lng]);

  //apparently the camera function won't work unless it's contained within itself.
  //onStarClick is an external function on App.tsx.
  //Essentially just takes the nearest star.
  function StarField({
    positions,
    alphas,
    starMap,
    onStarClick,
  }: {
    positions: Float32Array;
    alphas: Float32Array;
    starMap: Record<string, [number, number, number]>;
    onStarClick: (id: string) => void;
  }) {
    const { camera, gl } = useThree();
    const raycaster = useMemo(() => new THREE.Raycaster(), []);
    const mouse = useRef(new THREE.Vector2());

    useEffect(() => {
      //there's a slight issue when it comes to rotating the canvas,
      //and that is the event listener for clicking is detected each time, even when dragging to rotate

      let isDragging = false;

      const handleMouseDown = () => {
        isDragging = false;
      };

      const handleMouseMove = () => {
        isDragging = true;
      };

      //within the starmap data, there's essentially four objects. The xyz, and the added key.
      //The key data is based on the Hippocarus Identifier.
      //This function essentially uses raycasting in order to find the closest star the user has clicked.
      //Raycasting is akin to shooting a line within the space, where the searching algorithm finds the closest match.
      const handleClick = (event: MouseEvent) => {
        if (isDragging) return;

        //represents the box that's currently on the screen (in 2d).
        const rect = gl.domElement.getBoundingClientRect();

        //converts mouse pixel to normalised device coordinates (ndc). WebGL wants this instead of pixels.
        mouse.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse.current, camera);

        let closestId: string | null = null;
        let closestDistance = Infinity;

        //this is highly inefficient, but the best way I can do atm.
        //It's essentially going through the star objects everytime...
        for (const [id, pos] of Object.entries(starMap)) {
          const point = new THREE.Vector3(...pos);

          //getting the shortest distance.
          const distance = raycaster.ray.distanceToPoint(point);

          //distance tolerance.
          if (distance < 1.5 && distance < closestDistance) {
            closestDistance = distance;
            closestId = id;
          }
        }

        if (closestId) {
          onStarClick(closestId);
        }
      };

      //adding the event listeners to the renderer.
      //Them two move and downs are trackers for dragging. Should not handle the star clicking.
      gl.domElement.addEventListener("mousedown", handleMouseDown);
      gl.domElement.addEventListener("mousemove", handleMouseMove);
      gl.domElement.addEventListener("click", handleClick);

      return () => {
        gl.domElement.removeEventListener("mousedown", handleMouseDown);
        gl.domElement.removeEventListener("mousemove", handleMouseMove);
        gl.domElement.removeEventListener("click", handleClick);
      };
    }, [camera, gl, starMap, onStarClick]);
    return (
      <>
        <points>
          <bufferGeometry>
            <primitive
              attach="attributes-position"
              object={new THREE.BufferAttribute(positions, 3)}
            />
            <primitive
              attach="attributes-alpha"
              object={new THREE.BufferAttribute(alphas, 1)}
            />
          </bufferGeometry>

          <shaderMaterial
            vertexShader={vertexShader}
            fragmentShader={fragmentShader}
            transparent
            uniforms={{
              size: { value: 3.0 },
              color: { value: new THREE.Color("white") },
            }}
          />
        </points>
      </>
    );
  }
  const controlsRef = useRef<any>(null);

  //Camera controls is an orbit camera, so it wasn't as easy as just setlook at :tear:
  const goToStar = (id: string) => {
    console.log("Chat");
    if (!controlsRef.current || !starMap[id]) return;
    console.log("Are we firing?");

    const [x, y, z] = starMap[id];
    const starPosition = new THREE.Vector3(x, y, z);

    const cameraEnd = controlsRef.current._sphericalEnd; //value in CameraControl. The target in the sphere space.

    const starDirection = starPosition.clone().normalize(); //normalize turns the vector values to a distance of one. This is so the camera doesn't shoot forward.

    const newCameraDirection = starDirection.clone().negate(); //orbit cameras means that we will always look towards the center. The star direction calculates it, and negating the value means we can position ourselves to see the target.

    //https://stackoverflow.com/questions/30271693/converting-between-cartesian-coordinates-and-spherical-coordinates
    //:pray:
    const targetTheta = Math.atan2(newCameraDirection.x, newCameraDirection.z);
    const targetPhi = Math.acos(newCameraDirection.y);

    cameraEnd.theta = targetTheta;
    cameraEnd.phi = targetPhi;

    controlsRef.current._needsUpdate = true; //value in CameraControl. Triggers the movement.
  };

  useEffect(() => {
    if (focusedStarId) {
      goToStar(focusedStarId);
    }
    setFocusedStarId(null);
  }, [focusedStarId]);

  return (
    <>
      <Canvas
        camera={{ position: [0, 1, 3] }}
        style={{ width: "100vw", height: "100vh" }}
      >
        <ambientLight intensity={0.5} />
        <StarField
          positions={positions}
          alphas={alphas}
          starMap={starMap}
          onStarClick={onStarClick}
        />

        <mesh position={[0, -1.5, 0]} rotation={[Math.PI, 0, 0]}>
          <sphereGeometry
            args={[10, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.5]}
          />
          <meshStandardMaterial
            color="#222"
            roughness={1}
            metalness={0}
            side={THREE.DoubleSide}
          />
        </mesh>

        <CameraControls
          ref={controlsRef}
          //disabling zoom https://discourse.threejs.org/t/is-it-possible-to-disable-the-zooming-of-cameracontrols-react-three-drei/67476/4
          minZoom={0}
          maxZoom={0}
          minDistance={0.5}
          maxDistance={2.5}
          minPolarAngle={Math.PI * 0.5}
          maxPolarAngle={Math.PI * 0.9}
        />
      </Canvas>
    </>
  );
}
