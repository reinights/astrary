import { Canvas } from "@react-three/fiber";
import { OrbitControls, Text } from "@react-three/drei";
import * as THREE from "three";
import { useMemo } from "react";
import { julian } from 'astronomia';

//ChatGPT Help with shaders and converting values from ra/dec/mag to xyza.
//Conversation Link:
//https://chatgpt.com/share/67ffd32e-c694-8009-b8fb-27b7b4ebda98
const vertexShader = `
  attribute float alpha;
  varying float vAlpha;

  void main() {
    vAlpha = alpha;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = 2.0;
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const fragmentShader = `
  varying float vAlpha;

  void main() {
    gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha);
  }
`;

export default function NightSky({ stars, time, lat, lng }: { stars: any[], time: Date, lat: number, lng: number }) {
  
  //Function generated by ChatGPT: https://chatgpt.com/share/68013d8c-cb9c-8009-81e3-83b7db7676be
  function getGreenwichSiderealTimeRadians(jd: number): number {
    const T = (jd - 2451545.0) / 36525.0;
  
    let GMST = 280.46061837 +
               360.98564736629 * (jd - 2451545.0) +
               0.000387933 * T * T -
               (T * T * T) / 38710000;
  
    GMST = ((GMST % 360) + 360) % 360; // normalize to 0–360°
    return (GMST * Math.PI) / 180; // convert to radians
  }
  

  //the astronomia function seems to only take in values from years, months, and days.
  //this function splits the d/m/y from the h/m/s, uses the former to get the julian from astronomia, and add the remaining time to it.
  function getJulianDateFromDate(date: Date): number {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1; // JS months are 0-based
    const day = date.getUTCDate();
  
    const hours = date.getUTCHours();
    const minutes = date.getUTCMinutes();
    const seconds = date.getUTCSeconds();
  
    const jd0 = julian.CalendarGregorianToJD(year, month, day);
    const timeFraction = (hours + minutes / 60 + seconds / 3600) / 24;
  
    return jd0 + timeFraction;
  }

  // stars.csv includes the Right Ascension / Declination (RA/Dec). This is useful for plotting, but not really for realtime. (kind of like a lat and lon.)
  // Azimuth / Altitude (Alt/Az) are location and time-based angles that tell you where to look in the sky right now, great for rendering the night sky from the user's location and time.
  // In order to convert RA/Dec to Alt/Az, we would also need the Local Sidereal Time, which is the time it takes for the Earth's rotation to hit 360 based on distant stars. RA is also measured in LST.
  // This is because stars appear to move through the sky throughout the night due to Earth's rotation, and LST helps us figure out what part of the celestial sphere is currently visible for the observer.
  // Without this, RA/Dec would remain stationary and it would be difficult to have have a realtime slider that can display stars based on the user's location and time.
  // Formulas used in here are generated by ChatGPT in this conversation //https://chatgpt.com/share/67ffd32e-c694-8009-b8fb-27b7b4ebda98, I have merely modified it to work.
  
  function convertStarsToGeometryData(stars: any[], radius: number, time: Date, lat: number, lng: number) {
    time.setUTCSeconds(0, 0);

    const jd = getJulianDateFromDate(time);
    const gst = getGreenwichSiderealTimeRadians(jd);
    const lst = gst + (lng * Math.PI / 180);
    console.log(time)
    console.log(gst)
      
    const total = stars.length;
    const positions = new Float32Array(total * 3);
    const alphas = new Float32Array(total);
    
    let j = 0;
    let k = 0;
    
    for (let i = 0; i < total; i++) {
      const star = stars[i];
      if (star.ra == null || star.dec == null || star.mag == null) continue;
  
      const raRad = (star.ra * 15 * Math.PI) / 180;
      const decRad = (star.dec * Math.PI) / 180;
  
      // Hour angle = LST - RA
      let ha = lst - raRad;

      //essentially clamps ha values between -π to π
      if (ha < -Math.PI) ha += 2 * Math.PI;
      if (ha > Math.PI) ha -= 2 * Math.PI;
  
      // Observer’s latitude in radians
      const latRad = lat * Math.PI / 180;
  
      // Altitude
      const sinAlt = Math.sin(decRad) * Math.sin(latRad) + Math.cos(decRad) * Math.cos(latRad) * Math.cos(ha);
      const alt = Math.asin(sinAlt);
  
      // Azimuth
      const cosAz = (Math.sin(decRad) - Math.sin(alt) * Math.sin(latRad)) / (Math.cos(alt) * Math.cos(latRad));
      let az = Math.acos(Math.min(Math.max(cosAz, -1), 1)); // Clamp between -1 and 1
  
      // Az correction for hour angle
      if (Math.sin(ha) > 0) {
        az = 2 * Math.PI - az;
      }  
      // Alt/Az to XYZ
      const x = radius * Math.cos(alt) * Math.sin(-az); //mostly fiddling with the -values as it was a mirror of stellarium
      const y = radius * Math.sin(alt);
      const z = radius * Math.cos(alt) * Math.cos(-az);
  
      positions[j++] = x;
      positions[j++] = y;
      positions[j++] = z;
  
      const alpha = Math.max(0, 1 - star.mag / 4); //Magnitude filter
      alphas[k++] = alpha;
    }
  
    return {
      positions: positions.subarray(0, j),
      alphas: alphas.subarray(0, k),
    };
  }
  const { positions, alphas } = useMemo(() => {
    if (!stars || !stars.length) return { positions: new Float32Array(), alphas: new Float32Array() };
    return convertStarsToGeometryData(stars, 100, time, lat, lng);
  }, [stars, time, lat, lng]);
    return (
    <Canvas camera={{ position: [0, 1, 3] }} style={{ width: "100vw", height: "100vh" }}>
      <ambientLight intensity={0.5} />
    {/* Three.js recommends using instanced mesh with large quantities but using points seems to be the fastest way */}
    {/* https://discourse.threejs.org/t/better-performance-instanced-mesh-or-points/20293 */}
    <points>
        <bufferGeometry>
        <primitive
          attach="attributes-position"
          object={new THREE.BufferAttribute(positions, 3)}
        />
        <primitive
          attach="attributes-alpha"
          object={new THREE.BufferAttribute(alphas, 1)}
        />
        </bufferGeometry>

        <shaderMaterial
          vertexShader={vertexShader}
          fragmentShader={fragmentShader}
          transparent
          uniforms={{
            size: { value: 3.0 },
            color: { value: new THREE.Color("white") },
          }}
        />
      </points>

      <mesh position={[0, -1.5, 0]} rotation={[Math.PI, 0, 0]}>
        <sphereGeometry args={[10, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.5]} />
        <meshStandardMaterial color="darkgreen" side={THREE.DoubleSide} />
      </mesh>

      <OrbitControls enableZoom={false} minPolarAngle={Math.PI * 0.5} maxPolarAngle={Math.PI * 0.9} />
    </Canvas>
  );
}

